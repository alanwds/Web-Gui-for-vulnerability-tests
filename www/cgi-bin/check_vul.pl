#!/usr/bin/perl
#Script check_vul.pl
#Finalidade: Prover uma interface para que usuarios possam testar se estao vulneraveis
#Autor: Alan Santos - alanwds@gmail.com

#1 - Funcionalidade basica: Recebe IP, porta (se houver) e tipo de vulnerabilidade
#2 - Valida e sanitiza essas entradas.
#3 - Aciona o script correto conforme o tipo de teste


#LISTA DE CHECKS
#1 - Open SNMP 
#2 - Open DNS
#3 - Open NETBIOS
#4 - NTP - readvar (mode 6) 
#5 - NTP - monlist (mode 7)
#6 - SSDP - Cancelado

#Declaracao de modulos
use strict;
use warnings;
use utf8;

#Modulo para utilizacao de CGI
use CGI::CGI;

#Modulo para trabalhar com arquvos
use IO::File;

# Exibe erros no browser. Remover em producao.
#use CGI::Carp qw(fatalsToBrowser); 

#Modulo para capturar a saida de scripts externos
use IPC::System::Simple qw(system capture);

#Declara arquivo de controle
our $controlFile = '/tmp/controlFile';

#Declara o numero maximo de testes por ip
our $limitTeste = 20;

#Declaracao de variaveis
my $q = new CGI;

#Variavel isVulnerable como publica para poder ser usada pela funcao display_results
our $isVulnerable = '';
our $messageFromScript = '';
our $tmp = '';
our $tmp2 = '';

#Chama a funcao para checar se o arquivo de controle existe
checkControlFile();

print $q->header();

# Imprime stylesheet, heading etc
output_top($q);

if ($q->param()) {
    # Definicao de parametros, depois o formulario sera submetido

    #Pega o retorno do script (sempre sera um status 0,1 ou 2 procedido de da flag $, pode haver ou nao mensagem depois, se tiver, sera inserida na variavel messageFromScript).
    $tmp = chose_check($q);
    ($isVulnerable,$messageFromScript) = split("&",$tmp);

    display_results($q);
} else {

    #Funcao para imprimir texto descritivo
    output_text($q);

    # Imprime o formulario
    output_form($q);

    #Imprime o about
    output_about($q);
}

# Imprime o footer e end html 
output_end($q);

exit 0;

#-------------------------------------------------------------

#Funcao para log das mensagens do script
sub LOG{

        #Armazena a data e hora em uma variavel
        my $now = `date +"%b %d %R:%S"`;

        #remove a quebra de linha da data/hora
        chomp($now);

        #Recebe a string como parametro
        my ($logitem) = @_;

        #Adiciona a data/hora, espaco e a quebra de linha na linha
        $logitem = $now . " " . $logitem."\n";

        #Abre o arquivo de LOG LOCAL
        #open LOG, ">>check_vul.log" or die $!;

        #Armazena a strings recebida no arquivo
        #print LOG $logitem;

        #Fecha o arquivo
        #close LOG;

	#print "a entrada do log sera: $logitem";
	#exit 0;

        #Armazena a informacao no syslog
        my $temp = `/usr/bin/logger -i -p daemon.info $logitem`;

        #Joga a string no stdout
        #print $logitem;

}

#Funcao para testar se o arquivo existe. Se nao existir, ele ira criar
sub checkControlFile{

LOG "Checando se o arquivo de controle $controlFile existe";
#Testa se o arquivo existe
        if (-e $controlFile) {
                LOG "O arquivo $controlFile existe";
        } else {
                LOG "O arquivo $controlFile nao existe";
                open my $fh, '>', $controlFile;
                close $fh;
        }

}

# Funcao para inserir o IP no arquivo de controle
sub controlaTeste {

	my ($ip,$teste) = @_;
	my $tmp;
	my $newLine = "\n";
	my $file = ">>" . $controlFile;;
	#pega a data no formato DD/MM/AA
	my $date = `date +%d/%m/%y`;
	chomp($date);
	my $counter = 1;
	my $test;

	#Instancia o arquivo de controle para blacklist
	open CONTROL, $file or die "Erro inesperado. Favor tentar novamente";

	#Testa para verificar se o IP ja esta no arquivo. Se o ip nao estiver, ira inserir no arquivo e encerrar a funcao com 1, indicando que o teste pode continuar.
	#Se o IP estiver, ele vai chamar a funcao para checar quantas vezes ele foi inserido. Se for mais de 20, ele ira imprimir a mensagem de erro, se nao, ele ira incrementar o contador
	if(!procuraIP($ip)){

		#Concatena as strings no formato que entrarao no arquivo
        	$tmp = $date . "," . $ip . "," . $teste . "," . $counter;

        	#Armazena a strings recebida no arquivo
        	print CONTROL $tmp . "\n";
		
		#Fecha o arquivo
	        close CONTROL;
		return 1;

	}else{
		#Fecha o arquivo para o restante de possibilidades
                close CONTROL;

		#Pega o numero de vezes que o IP foi testado
		$counter = getCounter($ip);

		#Se ele foi testado mais de 20 vezes no mesmo teste, ira imprimir a mensagem de erro e retornar 0
		if($counter > $limitTeste){
			return 0;
		}else{ #Se houver a entrada no LOG, porem, o contador nao for maior que $limitTeste, ele incrimenta o contador no arquivo e permite a execucao do teste retornando 1 
			incrementaCounter($ip);	
			return 1;
		} 
	}

	print $tmp;


}

#Funcao para pegar o numero de vezes que o IP foi consultado
sub getCounter{

	my ($ip) = @_;
	my $file;
	my $match;
	my $count;
	my @tmp;

	open $file, $controlFile or die "Erro inesperado. Favor tentar novamente"; 

	#Percorre o todo o arquivo a fim de encontrar a linha com o ip em questao
	while( my $line = <$file>)  {   
	    #Se achar alguma linha que contenha o ip, ira armazenar na variavel match
		if($_ =~ m/$ip/){
			#Caso encontre, ira fechar o arquivo
			close $file;
			$match = $_;
			#Quebra a string, separando por virgula 
			@tmp = split(",",$match);	
			#Armazena o conteudo na variavel $count;
			$count = @tmp[3];
			return $count;
		}
	}

	#Caso nao encontre o counter, fechara o arquivo e retornara 0 para dar erro
	close $file;
	return 0;
}

#Funcao para incrementar o counter para testes no mesmo IP
sub incrementaCounter{

        my ($ip) = @_;
        my $file;
        my $match;
        my $newLine;
        my @tmp;
	my $tmp2;

        open $file, $controlFile or die "Erro inesperado. Favor tentar novamente";

        #Percorre o todo o arquivo a fim de encontrar a linha com o ip em questao
        while( my $line = <$file>)  {
            #Se achar alguma linha que contenha o ip, ira armazenar na variavel match
                if($_ =~ m/$ip/){
                        $match = $_;
                        #Quebra a string, separando por virgula
                        @tmp = split(",",$match);
			#Atribui o valor encontra na variavel $test
                        $tmp2 = @tmp[3];
			#incriementa a variavel do counter
			$tmp2++;
			#Reconstroi a linha com todas as informacoes necessarias
			$newLine = @tmp[0] . "," . @tmp[1] . "," . @tmp[2] . "," . $tmp2 . "\n";
		}
        }

	#Fecha o arquivo
	close $file;

	#Chama a funcao para substituir uma determinada linha por outra. Neste caso, sera passado a linha antiga ($match) e a nova linha a ser inserida.	
	#A funcao ira alterar a linha que conter o $match (que e a linha antiga) e substituir pelo conteudo de newLine
	#O retorno da funcao ja ira indicar se houve sucesso na substituicao do contador
	if(old2New($match, $newLine)){
		#Caso tenha dado certo, a funcao ira retornar 1
        	return 1;
	};

        #Caso nao encontre o counter, retornara 0 para dar erro
        return 0;
}

#Funcao para alterar o conteudo do arquivo
#Recebe dois parametros, a oldLine e newLine. Substitui a old pela new
sub old2New{

	my ($oldLine,$newLine) = @_;
	#Funcao que le todo o arquivo e insere o conteudo em uma variavel
	my $data = read_file($controlFile);

	$data =~ s/$oldLine/$newLine/gi;

	#Abre o arquivo e substitui o conteudo pelo conteudo alterado
	open my $file, '>:encoding(UTF-8)', $controlFile or die "Erro inesperado. Favor tentar novamente";;
    	print $file $data;
    	close $file;
 
    	return 0;

}

#Funcao para ler todo o arquivo e retornar o conteudo dentro de uma variavel
sub read_file {
    my ($filename) = @_;

    open my $in, '<:encoding(UTF-8)', $filename or die "Erro inesperado: $!. Favor tentar novamente";
    local $/ = undef;
    my $all = <$in>;
    close $in;
 
    return $all;
}

#Funcao para imprimir erro caso o limite ja tenha estrapolado
sub printLimitError{

	my ($ip) = @_;

	#Insere informacao no LOG
	LOG ("ATENCAO: O IP $ip foi testado mais de 20 vezes hoje");

	print $q->h2({-style=>'Color: red;'},"Erro: O IP $ip já foi testado muitas vezes. Você poderá testar esse IP novamente amanhã");
        backButton();
        exit 0;

}

#Funcao para verificar se o ip ja esta no arquivo
sub procuraIP {

	my ($ip) = @_;

	open(my $file,  "<",  $controlFile)  or die "Erro inesperado. Favor tentar novamente";

 	while (<$file>)  {

 		if (/$ip/)
 		{
			#Caso encontre, fecha o arquivo e retorna 1
			close $file;
			return 1;
		} 

  	}
	
	#Caso ele percorra o arquivo todo e nao encontre a entrada, devera fechar o arquivo e retornar 0
	close $file;
	return 0;

} 

# Funcao para imprimir as tags html, stylesheet e cabeçalho 
sub output_top {
    my ($q) = @_;
    print $q->start_html(
        -title => 'Teste seu servidor',

    );

	#Funcao para imprimir o javascriptpara validar o javascript
	output_javaScript();

    #Instancia css
    print "<div id=\"all\">";
    print "<link rel=\"stylesheet\" href=\"../estilo.css\">";


#imprime itens do CSS
print <<"EOF"; 
	<div class="container">
            <div class="page-header">
                <a href="http://www.rnp.br/servicos/seguranca"><img class="logoCais" src="../imagens/cais_logo.gif"></a>
    		<a href="http://www.rnp.br"><img class="logoRnp" src="../imagens/rnp_logo.png"><a/>
		<br />
                <h2>
                    vTest - Vulnerability checker 
                </h2>
	</div>
EOF
}

# Funcao que recebe o teste a ser executado e inicia o script necessario para tal 

sub chose_check {

    my ($q) = @_;
    my $isVulnerable= '';
    my $results = '';
    my $valid = '';
	

    #Atrabui o valor do parametro (recebido pelo form) ip para a variavel ip
    my $alvo = $q->param('alvo');
 
    #Declara a valiavel ip
    my $ip = $alvo;
    my $usercheck = $q->param('check');
    my %test = ('HEART' => '10', 'NTP7' => '7', NTP6 => '6', 'N' => '3', 'D' => '2', 'S' => '1', 'P' => '8');
    my $option = $test{$usercheck};

    #Se o teste for heartbleed, alem de IP, o script pode receber uma url (com ou sem porta). Se for outro teste, a entrada valida sera somente IP, portanto, a funcao validaIP sera acionada. 
    if (($alvo) && ($option eq '10')){

	#Chama funcao para validar a entrada para o teste do heartbleed 
	$valid = validaAlvo($alvo);

    } else {
    	#Valida IP antes de enviar para os scripts filhos. Se o IP for valido, ele insere a flag '1' na variavel $valid. 
    	$valid = validaIP($ip);
    }

    #Se valid = 1, ele ira atribui o valor 0 na variavel option, assim ele ira imprimir a funcao de erro printError
    $option = 0 if ($valid == 1) ;

	#Chama a funcao para limpar os arquivos (ira procurar por registros do dia anterior).
	cleanFile();

	#Depois da validação de entrada, ira passar passar para a funcao de controle, onde sera verificado se o IP ja nao esta em uma blacklist
	my $tmp = controlaTeste($ip,$option);	

	#Testa para verificar se o conteudo de $tmp e diferente de 1. Se for, chama a funcao para imprimir o erro e encerrar o scrip
	#print "O valor de tmp e: $tmp";
	if($tmp != 1){
                printLimitError($ip);
	}


    if($option == 1) {
        $results = capture("./openSNMP.pl",$ip );
    } elsif($option == 2) {
	$results = capture("./openDNS.pl",$ip ); 
    } elsif($option == 3) {
	$results = capture("./openNETBIOS.pl",$ip ); 
    } elsif($option == 6) {
        $results = capture("./ntpReadvar.sh",$ip );
    }elsif($option == 7) {
        $results = capture("./ntpMonlist.sh",$ip );
    }elsif($option == 8) {
        $results = capture("./poodle.pl",$ip );
    }elsif($option == 10) {
	$results = capture("./heartBleed.pl",$ip ); 
	#print "O retorno e: $results";
    }  else {
	#Funcao para imprimir erro;
	printError();
    }
	return $results;
}

#Funcao para limpar o arquivo. Ira remover todas as entradas do dia anterior 
sub cleanFile{
#PAREI AQUI
	#Pega a data do dia anterior
	#my $yesterday = `date -d "yesterday 13:00 " '+%d/%m/%y'`;
	#my $yesterday = `date -d "yesterday 13:00 " '+%d\/%m\/%y'`;

	my $date = `date +%d/%m/%y`;
        chomp($date);

	#Remove as quebras de linha
	#chomp($yesterday);

	#print "A data ficou $date";

	my @data = read_file($controlFile);
	my $newFile;

	#Percorre o conteudo de data (que sao as linhas do arquivo
	#Iremos testar cada linha, se nao comecar pelo dia de hoje, a linha nao sera inserida na variavel newFile que sera usada para sobrescrever o arquivo novo.
	while(<@data>){
		if($_ =~ m/^$date/){

			$newFile .= $_ . "\n";	
		}
	} 

	#print "O arquivo ficou assim: $newFile";

	#Abre o arquivo e substitui o conteudo pelo conteudo alterado
        open my $file, '>:encoding(UTF-8)', $controlFile or die "Erro inesperado: $!. Favor tentar novamente";;
        print $file $newFile;
        close $file;

        return 0;

}

# Funcao para imprimir texto explicativo
sub output_text {
    my ($q) = @_;

print <<"EOF";
        <div class="outputText">
        <h2>Entre com um IP ou Hostname para testar o servidor</h2>
EOF

}

#Funcao para validar a entrada para o teste do heartbleed. Sao entradas validas IPs, urls + porta(opcional).
sub validaAlvo{

	my ($alvo) = @_;

	#testa para saber se o alvo e uma URL valida (tambem testa se o item opcional porta esta presente).
        if( $alvo =~ m/^([A-Z\d\.-]{2,})\.([A-Z]{2,})(:\d{2,5})?/i )
        {
				return 0;
        }
	#Caso nao seja uma URL valida, ainda sera necessario testar se e uma entrada valida	
        elsif(!validaInputHeart($alvo)){
				return 0;

	} else { #Se nao for uma URL valida e nao for um IP valido, era retornar 1 para dar erro  
        
                                return 1;
        }


}

#Funcao para validar se a entrada do teste do heartbleed. Caso não seja uma URL, ainda pode ser um IP valido e/ou ip:porta 
sub validaInputHeart{

        my ($input) = @_;
	my $status;
	my $ip;

	#Verificar se existe o caracter : na entrada. Se existir, iremos quebrar a string em duas partes
	if ( $input =~ ":"){

		#Armazena o IP da variavel ip e a porta na variavel port
		my ($ip,$port) = split(':',$input);

		#Valida o IP e a porta. Se os dois tiverem OK, retorna 0 para a funcao validaAlvo, permitindo assim, que o teste prossiga
		if((validaPorta($port)) && (!validaIP($ip))){
			#Se estiver tudo ok, retorn 0 para que o teste possa prosseguir
			return 0;
		}else{

			#Se tiver qualquer problema com o IP ou a porta, retorna 1 para cancelar o teste
			return 1;
		}

		
	}else{ #Caso nao seja nem um IP+porta nem uma URL, ainda pode ser um IP valido
	
		if(validaIP($ip)){ #Se o IP for valido, retorna 0 para que o teste continue
			return 0;
		}else{
			return 1;
		}	
	}

}

#Funcao para validar porta de entrada
sub validaPorta{

	my ($port) = @_;

	#Se a porta for maior que zero e menor que 65535, e uma porta valida
	if(($port > 0) && ($port < 65535)){
		#Retorna 1 para verdade
		return 1;
	}else{

		#Como nao e uma porta valida, retorna 0
		return 0;
	}
}

#Funcao para validar o IP no proprio script (garantir a validacao nao somente no javascript)
sub validaIP{

	my ($ipaddr) = @_;

	#Verifica se existe 4 octetos e se tem 1,2 ou 3 digitos em cada um.
	if( $ipaddr =~ m/^(\d\d?\d?)\.(\d\d?\d?)\.(\d\d?\d?)\.(\d\d?\d?)$/ )
	{
   		#Verificar se os digitos estao dentro do range 0-255 
    		if($1 <= 255 && $2 <= 255 && $3 <= 255 && $4 <= 255)
    			{
			        return 0;
			}
		else
    			{
				return 1;
    			}
	}
	else
	{
				return 1;
	}
}

#Funcao para imprimir erro
sub printError{

	print $q->h2({-style=>'Color: red;'},"Erro: IP, hostname ou opção inválida");
        backButton();
        exit 0;
}

#Funcao para imprimir o about
sub output_about {

#imprime div oculta que tem informacos sobre o heartbleed
print <<"EOF";
	<br />

        <div id="boxExplicativo">
	</div>
	<br />
EOF

#imprime a div about, com mais informacoes sobre a ferramenta 
print <<"EOF";
        <div class="boxAbout">
        <h2>Aviso Legal</h2>
        <h3>
         vTest é uma ferramenta para detecção de vulnerabilidades desenvolvida pelo CAIS (Centro de Atendimento a Incidentes de Segurança).<br />
        Com o vTest é possível verificar se ações corretivas para determinadas vulnerabilidades foram efetivas e descobrir eventuais novas vulnerabilidades.
        <br />
        <br />
        O CAIS não garante a precisão ou desempenho da ferramenta e seus resultados, não se responsabiliza por possíveis inconsistências nos resultados apresentados.
        <br />
        Sendo assim, recomenda-se que o vTest seja utilizado como ferramenta de auxílio no tratamento de vulnerabilidades, eximindo-a de qualquer responsabilidade baseada em seus resultados.
        <br />
        <br />
        A utilização do vTest ou dos resultados através dele obtidos é de inteira responsabilidade do usuário.
        O CAIS recomenda o uso do vTest somente em redes sob a responsabilidade do usuário.
        </h3>
        </div>

        <br />
        <a href="http://vtest.cais.rnp.br/cgi-bin/check_vulEn.pl"><img class="en_US" src="../imagens/en_US.jpg"></a>
        <a href="http://vtest.cais.rnp.br/cgi-bin/check_vul.pl"><img class="pt_BR" src="../imagens/pt_BR.jpg"></a>
EOF
}

# Funcao para imprimir o rodape e as tags html de fechamento
sub output_end {
    my ($q) = @_;
    print $q->end_html;
}

# Funcao para imprimir os resultados do teste
# Tudo dependedera do resultado da variavel isVulnerable
# 0 - Servidor nao vulneravel
# 1 - Servidor vulneravel
# Qualquer coisa diferente - Algum erro aconteceu
 
sub display_results {
    my ($q) = @_;

    my $alvo = $q->param('alvo');
    my $usercheck = $q->param('check');
    my %test = ('HEART' => 'Heart Bleed', 'NTP7' => 'NTP(monlist)', 'NTP6' => 'NTP(readvar)', 'N' => 'Open NETBIOS', 'D' => 'Open DNS', 'S' => 'Open SNMP', 'P' => 'SSL Poodle');
    
    #Armazena o IP de origem do cliente
    my $clienteIP = $ENV{REMOTE_ADDR};

    #Armazena a informacao no SYSLOG
    LOG "ORIGEM=$clienteIP DESTINO=$alvo TESTE=$usercheck RESULTADO=$isVulnerable";

    print $q->h4("Teste realizado: $test{$usercheck}");
    print $q->h4("Alvo: $alvo");

    #Testa o resultado, se for 1, esta vulnerável, se for diferente de 1, printa a msg de retorno
    if($isVulnerable eq '1'){

	print $q->h2({-style=>'Color: red;'},"Resultado: Este servidor está vulnerável");
	#Testa se existe retorno do script. Se existir, o retorno sera apresentado aqui
	if($messageFromScript){
		print $q->h4({-style=>'Color: red;'},"Saida: $messageFromScript");
	}

    }elsif ($isVulnerable eq '0'){

	print $q->h2({-style=>'Color: green;'},"Resultado: Este servidor não parece estar vulnerável");

	#Testa se existe retorno do script. Se existir, o retorno sera apresentado aqui
	if($messageFromScript){
                print $q->h4({-style=>'Color: green;'},"Saida: $messageFromScript");
        }


    }elsif ($isVulnerable eq '2'){

	 print $q->h4("Não foi possível testar o servidor.");
	 print $q->h4("Provavelmente, não está vulnerável.");
	 print $q->h4("Saída: $messageFromScript");

	}

	backButton();

}

#Funcao para imprimir o botao voltar

sub backButton{

	 print "<input type=\"button\" value=\"Voltar\" class=\"voltarBotao\" onClick=\"history.go(-1)\">";

}

# Imprime o formulario
sub output_form {

    #Declaracao do vetor para armazenas os checks
    my %checks = ('HEART' => 'Heart Bleed', 'NTP7' => 'NTP(monlist)', 'NTP6' => 'NTP(readvar)', 'N' => 'Open NETBIOS', 'D' => 'Open DNS', 'S' => 'Open SNMP', 'P' => 'SSL poodle');

    my ($q) = @_;

print "<div id=\"contact-area\">";
    print $q->start_form(
        -name => 'main',
        -method => 'POST',
	#-onsubmit => 'return ValidateIPaddress()'
	-onsubmit => 'return validaEntrada()'
    );

    print $q->start_table;

    print $q->Tr(
      $q->td(
 	#$q->textfield(-name => "ip", -size => 50, -placeholder => "xxx.xxx.xxx.xxx", maxlength => "15")
 	$q->textfield(-name => "alvo", -size => 50, -placeholder => "IP ou hostname")
	),

     $q->td(
        $q->popup_menu(
          -name => 'check',
         -values => [keys %checks],
         -labels => \%checks,
	 -id => 'dropDownMenu',
	 -onChange => 'showTab(value)',
       )
     ),

     $q->td(

          $q->submit(
		-value => 'Testar',
		-class => 'send_message',
	)
     ),
	
	$q->td('&nbsp;')
    );

    print $q->end_table;
    print $q->end_form;

#Fecha as DIVs
print "</div>";
print "</div>";
print "</div>";

}

sub output_javaScript{

#Funcao para validar o IP. So sera aceito IPv4
print <<"EOF";
<script>

function validaEntrada(){

	var target = document.forms["main"]["alvo"].value;
	var check = document.forms["main"]["check"].value;
	var tmp = '0';

	//Testa para verificar o tipo de teste. Se for o teste for heartbleed, sera necessario validar a entrada como URL, IP e possivelmente, porta
	if(check == "HEART"){

		//Testa para verificar se a URL e valida ou nao
		if(!ValidateURL(target)){
                        tmp++;
		}

		//Testa para saber se e um ip e se e valido
		if(!ValidateIPaddress(target)){
                        tmp++;
                }

		//Se tmp for maior, significa que o valor inserido atendeu pelo menos um dos dois criterios (IP ou URL). 
		if(tmp>1){
			alert('ATENÇÃO: a entrada "'+target+'" não é uma entrada válida.');
			return false;
		}
	}else{ //Se nao for, ira validar uma {

		//valida o ip, se false, retorna false para a pagina e o formulario nao e submetido
		if(!ValidateIPaddress(target)){
			alert('ATENÇÃO: a entrada "'+target+'" não é uma entrada válida.\\nEntre com um IPv4 válido.');
  			return false;
		}

	}
}

//Funcao para validar a URL + Porta (obs: a porta e opcional)
function ValidateURL(url) {

	var str = url;

	if( /^([A-Z\\d\\.-]{2,})\\.([A-Z]{2,})(:\\d{2,5})?/i.test(str) ){
		return true;
	} else{
		return false;
	}

}

//Funcao para validar o IP
function ValidateIPaddress(ip) {

//recebe o valor do campo ip e armazena na variavel ip
	var ip2 = ip; 
	//alert('O ip e: '+ip2);
  	var blocks = ip2.split(".");
 	if(blocks.length === 4) {
    		return blocks.ip2(function(block) {
      		return parseInt(block,10) >=0 && parseInt(block,10) <= 255;
    	});
  	}
	
	//alert('ATENÇÃO: '+ip2+' não é um ip válido. \\nFavor inserir um IPv4 válido.');
  	return false;
	
}

//Funcao para imprimir a caixa que explica os formatos aceitos pela ferramenta
function showTab(select) {
	var content;

	if(select == "HEART"){
		content="Entre com um IP ou URL<br />Você pode especificar uma porta: exemplo.com.br:443. A porta default é 443.";
	}

	if(select != "HEART"){
                content="Entre com um IP.<br />Exemplo: xxx.xxx.xxx.xxx";
        }
	
	document.getElementById("boxExplicativo").innerHTML = content;
}

</script>  
EOF

}
